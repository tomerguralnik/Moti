from functools import wraps
from pathlib import Path
import importlib
import re
from inspect import isclass
import sys

class Parser:
	"""
	The parser class collects all parsers in the parsers directory under the conditions:
	1. the module the parser is inside of has a variable include and it's set to 1
	2. the name of parser begins with parse_
	3. the parser has a variable called fields
	After collecting all the parsers the fields variable will contain all the fields
	there is a parsers to
	The mapping variable contains a mapping between fields and parsers that parse them
	"""
	def __init__(self, fields = None):
		"""
		Collects parsers and initiates fields and mapping
		If fields input variable isn't None then collects only parsers that parse a field from fields

		:param fields: list of fields, defaults to None
		:type fields: list or None(,optional)
		"""
		self.fields = []
		self.mapping = {}
		utils = Path(__file__).parent.absolute() #path to utils
		parsers = utils/'parsers'
		sys.path.insert(0, str(utils))
		for path in parsers.iterdir():
			if not (path.is_file() and path.suffix == '.py'):
				continue
			m = importlib.import_module(f'{parsers.name}.{path.stem}')
			if not 'include' in m.__dict__:
				continue
			if m.__dict__['include'] == 0:
				continue
			for name in m.__dict__:
				val = m.__dict__[name]
				if not(re.match('parse_*', name) and callable(val) and 'fields' in val.__dict__.keys()):
					continue
				for field in val.__dict__['fields']:
					self.fields.append(field)
					if not field in self.mapping:
						self.mapping[field] = []
					self.mapping[field].append(val)
		if fields != None:
			for field in self.fields:
				if field in fields:
					continue
				del self.mapping[field]
			self.fields = list(filter(lambda x: x in fields, self.fields))
			
	def generate_queues(self):
		"""
		Create queue names based on availible parsers

		:return: a list of queues based on availible parsers
		:rtype: list 
		"""
		queues = []
		for field in self.fields:
			for i in range(len(self.mapping[field])):
				queues.append(f"{field}/{i}")
		return queues

	def decode_queue(self, queue):
		"""
		Given a queue name generated by generate_queues return the corresponding parser

		:param queue: queue name
		:type queue: str
		:return: a parser corresponding to the queue
		:rtype: callable
		"""
		field, number = queue.split('/')
		return self.mapping[field][int(number)]

	def parse_field(self, field, data, context):
		"""
		Run all parsers corresponding to field and return 
		all of their results in a list
		:param field: field name
		:type field: str
		:param data: data to parse
		:tpye data: something that the parsers can parse
		:param context: context for parser to save it's data at
		:type: str
		:return: a list containing the data parsed by every parser that parses this field
		:rtype: list
		"""
		return [parser(data, context) for i in self.mapping[field]]

 

